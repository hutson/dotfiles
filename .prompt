#!/usr/bin/env bash

#====================================================
# Custom Bash Shell Prompt
#
# This script only needs to be sourced upon logging into a system to override the default Bash prompt.
#====================================================

# Retreiving the current files real directory path is handled by the following code, which was borrowed from this excellaent answer on StackOverflow - https://stackoverflow.com/questions/59895/getting-the-source-directory-of-a-bash-script-from-within/246128#246128
SOURCE="${BASH_SOURCE[0]}"
while [ -h "$SOURCE" ]; do # resolve $SOURCE until the file is no longer a symlink
  DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
  SOURCE="$(readlink "$SOURCE")"
  [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE" # if $SOURCE was a relative symlink, we need to resolve it relative to the path where the symlink file was located
done
DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
source "${DIR}/scripts/git-prompt.sh"

export PROMPT_ENABLE_GIT_REPO_IDENTIFICATION=1 # Enable the display of a repository's (GIT) name for the repository stored in the current directory.

# If `bc` is not in the user's PATH do not display load percentage.
if command -v bc &> /dev/null; then
	export PROMPT_ENABLE_LOAD=1 # Enable the display of a system's current, total, utilization as a percentage.
else
	export PROMPT_ENABLE_LOAD=0
fi

COLOR_OFF='\[\e[0m\]'	# Remove all color modifications.

COLUMN_FIX='\[\033[G\]'	# Forces the Bash prompt to always go to the first column. Resolves the issue where text is sometimes off by two characters as a result of control characters such as ^C.

# Regular colors.
BLACK='\[\033[0;30m\]'		# Black.
RED='\[\033[0;31m\]'		# Red.
GREEN='\[\033[0;32m\]'		# Green.
BROWN='\[\033[0;33m\]'		# Brown.
BLUE='\[\033[0;34m\]'		# Blue.
PURPLE='\[\033[0;35m\]'		# Purple.
CYAN='\[\033[0;36m\]'		# Cyan.
WHITE='\[\033[0;37m\]'		# White.

# Bold colors.
B_BLACK='\[\033[1;30m\]'	# Black.
B_RED='\[\033[1;31m\]'		# Red.
B_GREEN='\[\033[1;32m\]'	# Green.
B_YELLOW='\[\033[1;33m\]'	# Yellow.
B_BLUE='\[\033[1;34m\]'		# Blue.
B_PURPLE='\[\033[1;35m\]'	# Purple.
B_CYAN='\[\033[1;36m\]'		# Cyan.
B_WHITE='\[\033[1;37m\]'	# White.

# High intensity colors.
I_Cyan='\[\033[0;94m\]'		# Cyan.

#! Retrieve the number of unique proessor cores.
# Retrieve the number of unique processor cores on the system.
GetNumberOfCores()
{
	# Get a count of the unique cores in the system.
	local cores=`cat /proc/cpuinfo | grep "core id" | uniq | wc -l`

	# If that approach did not work then query just the number of processors reported by the system.
	if [ "${cores}" -le 0 ]; then
		cores=`cat /proc/cpuinfo | grep "processor" | uniq | wc -l`
	fi

	# Make sure to return a value greater than zero (Because you have at least one processor core, right?).
	if [ "${cores}" -gt 0 ]; then
		echo "${cores}"
	else
		echo 1
	fi
}

LoadPrompt()
{
	PS1="\n${COLUMN_FIX}"

	# Set user portion of the prompt based on the administrative powers of that user.
	PS1="${PS1}${B_BLACK}("
	if [ "${UID}" -eq 0 ]; then
		if [ -n "${SUDO_USER}" ]; then
			PS1="${PS1}${B_YELLOW}"
		else
			PS1="${PS1}${B_RED}"
		fi
	else
		PS1="${PS1}${CYAN}"
	fi
	PS1="${PS1}\u"

	PS1="${PS1}${B_BLACK}@"

	# Set host portion of the prompt based on whether the host is local or remote.
	if [ -n "${SSH_CONNECTION}" ]; then
		PS1="${PS1}${B_YELLOW}"
	else
		PS1="${PS1}${CYAN}"
	fi
	PS1="${PS1}\H${B_BLACK})"

	# If option is enabled, print the system's utilization.
	PS1="${PS1}\$(if [ \${PROMPT_ENABLE_LOAD} -eq 1 ] && \$(command -v bc &> /dev/null); then "

		# Current 1 minute system load.
		local load="\$(uptime | awk -F 'load average' '{ print \$2 }' | cut -d, -f1 | sed 's/: //g')"
		local scale="100"
		local percentUtilization="\$(echo \"scale=0;${scale} * ${load} / ${NUMBER_OF_CORES}\" | bc)"

		PS1="${PS1}printf '%s%s' '-(' '${CYAN}'; echo -n \"${percentUtilization}\"; echo -n \"%\"; printf '%s%s' '${B_BLACK}' ')';"

	PS1="${PS1}fi)"

	PS1="${PS1}-"

	# Current working directory.
	PS1="${PS1}${B_BLACK}(${CYAN}\w${B_BLACK})"

	# Begin a new command prompt line.
	PS1="${PS1}\n"

	# Current datetime.
	PS1="${PS1}(${CYAN}\$(date '+%H:%M %Z')${B_BLACK})"

	# If option is enabled, print the working directory's Git branch name.
	PS1="${PS1}\$(if [ \${PROMPT_ENABLE_GIT_REPO_IDENTIFICATION} -eq 1 ]; then "

		PS1="${PS1}printf '%s%s' '-(' '${CYAN}'; __git_ps1 '%s'; printf '%s%s' '${B_BLACK}' ')';"

	PS1="${PS1}fi)"

	# Add input indicator before the user's input prompt.
	PS1="${PS1}${B_BLACK}--> "

	# Reset color back to the default which will be overwritten by subsequent output.
	PS1="${PS1}${COLOR_OFF}"
}

# Make a cache of the number of cores on the current system. This allows us to avoid retrieving this information every time the prompt is generated. Instead, the number is only retrieved when this file is sourced.
export NUMBER_OF_CORES="$(GetNumberOfCores)"

# Limit number of path segments displayed on the user's command line to 2 plus the alias for the user's home directory, a.k.a. ~.
export PROMPT_DIRTRIM=2

# Call the load prompt function to set the user's prompt to the custom version.
LoadPrompt
